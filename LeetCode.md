# LeetCode

## 平时笔记

**T1****两数之和（****Two Sum****）****//C++**

简单来说题目就是输入序列和目标值，输出序列中满足和为目标值的两个数的位置。

学习以下几点：

①向量vector的使用，C++提供了一系列STL(Standard Template Library)即模板库，模板库包括容器、迭代器、空间配置器、配接器、算法、仿函数六个部分。本例中要使用的有<vector>和<map>。

【借鉴】②暴力思路很简单，注意枚举的时候三角形遍历，不要重复。基于目标值的哈希是很好的思路，可以把复杂度从O(n^2)降到O(m)。

③注意变量名和代码格式的规范性，数组索引命名当然应该用index



**T2****两数相加（****Add Two Numbers****）****//python3**

 对照他给定的ListNode的定义方式去写就好了，python这个if的写法真的是很英语了，多个变量同时赋值也非常的语言化，总的来说确实好用。

 

**T3****无重复最长子序列****(Longest Substring Without Repeating Characters) //C++**

这道题刷得比较艰难，在线调试没有一遍过，还是在线下编译调试了半天才发现三处问题。第一是需要注意length()函数返回的值和角标的关系：最后一个元素的角标是长度减1。平时不会在这上面犯错，但是出现循环条件判断的时候容易出错。第二处是本例有两种情况，元素直接入队、出队重复元素后入队，两种情况都要对入队元素的哈希进行修正，我一开始漏掉了后一种。第三处是直接复制粘贴导致的（发现第二个问题之后），把条件判断粘过来做赋值，直接导致赋值无效。

【思路】因为必须是连续的，所以扫描一遍就可以了，当入队的元素导致了重复时，队首元素出队直到不再重复。

 

**T4****两有序数组的中位数****(Median of Two Sorted Arrays) //C++**

思路来得很快，我的思路来自归并排序。这里需要先强调一下vector的用法，真的非常好用。

```
vector<int> a ;                              //声明一个int型向量a
vector<int> a(10) ;                         //声明一个初始大小为10的向量
vector<int> a(10, 1) ;                      //声明一个初始大小为10且初始值都为1的向量
vector<int> b(a) ;                           //声明并用向量a初始化向量b
vector<int> b(a.begin(), a.begin()+3) ;        //将a向量中从第0个到第2个(共3个)作为向量b的初始值
声明了向量之后，常用的操作有a.size()、a.empty()、a.clear()，还有神奇的b.swap(a)可以交换两个向量，非常好用。
```

二路归并的思路就是：设置两个指针，每次将两个指针对应的较小的数字归并，对应指针向后移动一步，如果有移动到头的指针，直接将另一路合并过来。寻找中位数的道理相同，分奇数偶数讨论即可。时间复杂度O(min(m+n))。需要注意的是leetcode不能另外开空间，它给定的数组长度是多少，就只能用这一片内存，再扩展的话会出问题。

【借鉴】本题可以优化到O(log(m+n))，思路来自两有序数组找第k小数问题。因为合并序列中必然有k-1个数小于等于k，假设这k-1个数有p个来自序列1，q个来自序列2，则必然满足如下条件：p+q=k-1；且这p+q个元素均小于第k小数。这样的话第p+1个和第q+1个数字中的较小值就是我们需要寻找的值。初始化p=q=(k-1)/2，如果第p个数小于第q个数，说明序列1中的数字都偏小了，全部舍弃，反之亦然。递归寻找第k-p或者第k-q小数，终止条件为：寻找第2小数（直接返回较小值）；p和q相等，返回后一位的较小值；较短序列到头，返回较长序列的k小数。



**T5****最长回文子串****(Longest Palindromic Substring) //python3**

【思路】分类讨论，串长可能是奇数/偶数，因为问题具有最优子结构（回文串去掉两头也是回文串）和无后效性，可以用DP的思路来解决，复杂度O(n^2)。需要注意的是本题还有一个分类讨论，就是串为空或者只有一个字母，一般来讲也能普适性的解决，但是实际操作的时候有可能会不对（比如串为单个字符的时候返回了空串）。

【借鉴】大致浏览了discussion里的思路，基本和我的想法一样，但是注意本题依然可以优化，https://blog.csdn.net/qq_17550379/article/details/84022674给出了Manacher算法的优化思路，类似的道理在KMP算法中也有应用。



**T6****之字转换****(ZigZag Conversion) //python3**

【借鉴】本题一方面学python里面list和字符串的定义与处理，与C甚至MATLAB等语言有很大不同。另一方面展示了一个问题可以怎样从另一个角度来思考，示例本身的格式可能会极大地影响对问题的解读，所以能否跳出示例所限制的条条框框就很关键——就像这道题，在草稿纸上画一个斜的“之”字，就很清晰了。



**T7****整数倒置****(Reverse of Integer) //C++**

主要要注意考虑全面，用long long来储存可能越界的数值并判断越界与否，需要注意的就是-maxlongint取绝对值之后是溢出的，操作数就应该直接用64位整型。



**T8****字符串转数字****(String to number atoi) //python3

【思路】打表

【注意】①python取区间是左闭右开的②corner condition优先考虑③python如果要去掉指定位置的字符，不要用replace直接置换指定字符，有可能把别的位置相同字符都置换掉了，.strip一样的道理

 

**T9****回文数****(Palindrome Number) //C++**

直接用T7的程序就行了，小于零直接返回0。另外可以加一句判断，如果这个数是10的整数倍，那就可以直接返回0；也可以尝试加更多剪枝语句，会略微快一点点。



**T10****正则表达式匹配****(Regular Expressing Matching) //python3

【借鉴】

方法一：递归（为了方便书写，*用#代替）

本题有明显的子结构，这是递归和动归思路来源的必要条件。比如讲abb和ab#是匹配的，如何判断出来呢？首要条件是a和a匹配，然后判断bb和b#是否匹配（问题的规模缩小了），都满足之后即证明两者匹配

递归边界（为什么讨论匹配串？因为模式串长度为零的时候匹配的匹配串可能还非常长！比如''和‘a#b#c#...’是匹配的）

1. 匹配串长度为零，此时除非模式串长度也为零，否则返回false
2. 匹配串长度为一（为什么边界一定要做两个？因为匹配串的长度可能是减一也可能是减二，并且后面涉及对第二位的判断，所以必须有一个长度为一的边界），此时除非模式串长度也为一，并且匹配（相等或者匹配串是'.'）

如何拆分成子问题呢？这里干扰视线的主要是#可能会让前缀字符重复很多次，如果匹配串中没有星号那么一切问题都很简单，所以容易想到的是：

1. 如果匹配串第二位不是#，那么模式串和匹配串首位相等的情况下（或者匹配串开头'.'），可以将问题等价为子问题（二者各自去掉首位后再比较）
2. 如果匹配串的第二位是#，首先要考虑的是，会不会匹配串这前两个都是无用字符？比如讲a和a#a，他们是匹配的，前提是把a#看做a重复零次，所以要检查（s，p[2:lenp]），同时，只要首位是match的，也可以缩减为子问题（即模式串去掉首位，匹配串去掉前两位），这里肯定要写一个循环来判断，因为不知道#能去掉模式串的多少个首位。注意到，ab和.#这个妖孽的例子也是满足这样的判断方式的（变成了空串的匹配），事实上.#似乎能表达一切式子……

【思路】

方法二：DP（DP是模仿递归自己推的，感觉非常不简洁）

发现递归的思路重复计算了很多计算过的自问题，所以觉得应该可以改成递推的形式

从后向前推，设定i表示当前模式串串长度，j表示匹配串长度，dp[i,j]记录布尔值

边界条件dp[0,0]=1，dp[1,1]=最后一位是否匹配，其余j=0/1的部分全部置零

二重循环递推，讨论当前匹配串的第二位是不是*

1.  如果不是，dp[i,j]= false if not i（防止匹配串长度为零）first index match and dp[i-1,j-1]
2.  如果是，dp[i,j]=1 if dp[i,j-2]==1。模仿递归的思路，这里可初始化k为i，当当前模式串的首位和匹配串可以匹配时，k可以递减，以此模拟#重复表示多个符号的情况



**T11****最能装水的容器****(Container With Most Water) //C++**

本题的关键在容器的高度由短板决定，从两边向中间枚举是容易想到的，在向中间枚举的过程中比两边更低的板子是可以直接忽略的（这也是容易想到的）。

【借鉴】优化到O(n)的关键在于只用移动短板，因为对于固定的短板而言，长板的那段向短板靠近只会得到更差的结果（为什么？因为容器能装多少水是由短板决定的！两边都只能变长的情况下动长板毫无意义，所以要增加容量应该是找到两个尽可能远的长板，优化的对象永远是相对短的那一个）。所以在两边向中间枚举的过程中，只用将短板的一方向长板一方靠近，这样有可能会出现更优的解，不会遗漏最优解。

【思考】我觉得这提供了一种思维方式，贪心的过程中，可以思考怎样变化能够使得结果更好，对注定使结果更差的分支，可以直接剪掉，故可以思考怎样变化注定使结果变差。

 

**T12****阿拉伯数字转罗马数字****(Integer to Roman) //C++**

本题的关键麻烦在于4、9、40等这些特殊数字，如果讨论来解决非常麻烦。

【借鉴】直接打表，干脆将所有特殊数字打表，就迎刃而解。

 

**T13****罗马数字转阿拉伯数字****(Roman to Integer) //C++**

同样是打表，这次思路就很清楚，先对比两个连在一起的，再对比单字符的就可以了。



**T14****最长公共前缀****(Longgest Common Prefix) //python3**

找到最短的那个，从头开始逐字符判断即可

【注意】本题是典型的反面判据：为了代码的简单性，我设置的是一旦发现不同就退出，由于是二重循环，需要设置一个flag变量break两次，外层的break一定要写在内层循环之后，否则很容易出现问题。



**T15****三数之和****(3 Sum) //python3**

【思路】由于样例中给出的三元组都是有序的，所以显然应该先对输入序列排序。本题至少应该优化到N^2，所以排序的复杂度可以不计。设置三个指针变量，i、j、k，代表三个数在数组中位置，如果i从开始向末端移动，那么j从i+1的位置向末端移动，由于nums是有序的，对同一个i而言，k只需要从nums的末端扫描到j+1的位置即可。
优化的关键在于，如果nums[i]和num[i-1]一样的话，直接continue就好了，因为如果nums[i]==nums[i-1]，由num[i]计算出的结果必然是num[i-1]的子集。



**T16****三数之和最近****(3 Sum Closest) //python3**

【思路】和上面一模一样，计算误差，对每个i，k只向一个方向移动，移动到对当前j来说误差最小的位置。如果对j来说这个k是最好的，那么对j+1来说，更好的k不可能向右移动！因为向右只会让误差更大。



**T17****电话号码字母组合****(Letter Combinations of a Phone number) //python3**

【思路】检讨，我第一反应居然是递归。这根本没有必要递归的，递归是自己浪费系统堆栈。自己拿一个list把结果存起来，从1个字母推到n个字母就好了，每一步把上一步的结果从list里面删掉

【注意】如果要用remove删，删len（上次的len）次ans[0]就行了，千万别删每次去删ans[j]，依次执行会出问题的



**T18****四数之和****(4 Sum) //python3**

【思路】照搬3数和的思路，马马虎虎凑了个N三方的程序怼过去了，还不错，如果按有序性break的话，如果target正常其实勉强算常数比较大的N平方？

【借鉴】其实计算并储存两数之和然后用字典检索就好了，可以优化到N平方的，不过我懒，不想写这个代码了



**T19****去除链表倒数N位数****(Remove Nth Node from End of List) //python3**

【思路】英语翻译题

【注意】要细心，设计链表的题，注意头结点的处理。另外corner conditon：输入的链表只有一个元素怎么办？



**T20****有效括号****(Valid Parentheses) //python3**

【思路】第一眼栈

【注意】空栈单独判断



**T21****合并有序链表****(Merge Two Sorted Lists) //python3**

【思路】英语翻译

【学习】python不需要new，直接调用构造函数就行了，非常方便



**T22****生产括号****(Generate Parenthese) //python3**

【思路】栈混洗，Catalan数，递归生成即可

【注意】我尝试了将ans放在全局变量，发现它似乎会随着测试数据的更迭而变化（append的话会把上一个数据的结果也保存下来，所以最好不要放全局）



**T26****有序列表去重****(Remove Duplicates from Sorted Array) //python3**

【思路】英语翻译

【注意】时刻注意下表是否越界



**T27****去除元素****(Remove Element) //python3**

【思路】英语翻译

【注意】时刻注意下表是否越界



**T28****实现 strStr()****(Inplement strStr()) //python3**

【思路】英语翻译，人生苦短我用python，python的字符串集成了.find函数，重载了查找字符串的功能！



**T29****两数相除****(Divide Two Intergers) //python3**

本题相当无趣，主要是负数情况的讨论，非常boring



**T35****寻找插入位置****(Search Insert Position) //python3**

【思路】分治法，cornor condition是输入空列表，one pass



**T38****数数****(Count and Say) //python3**

【思路】递推，能不用递归尽量不用，想了半天发现实在是没有使用递归的必要性，无论是思维量还是运算量上感觉都省不到哪儿去。



**T39****组合之和****(Combination Sum) //python3**

【思路】本题子结构十分明显，最自然也最合理的思路只能是递归。

【注意】

1. 像这道题，为了节约内存，我已经尽可能地减少递归调用的参数了，需要注意的是，保存在对象初始化时的ans，那个ans在被调用的类函数中要做初始化，不然每个样例的结果会在里面累加。。。
2. append实在是一个不太好用的函数，说实话我写python到现在觉得方便是方便，但这功能确实有点冗余，因为append是对自身的一个过程，在递归调用的时候经常把list.append()当成一个列表（然而其实是None），还不如直接list+[new element]来得舒服。。。

【思考】leetcode的用户着实有点懒，我这个解法完全没有优化也干掉了82%/100％，因为排了序，所以查找的时候可以用二分查找的，还可以优化。内存也是，可以思考能不能不把历史存在递归的参数中，回溯得到结果可以吗？



**T40****组合之和2****(Combination Sum 2) //python3**

【思路】我懒，想把上一题的代码直接搬过来。思考了一下发现肯定不行，因为如果有重复元素的话，肯定会出现重复组合。所以最开始的想法是，照搬上题代码，加一个hash。但是对列表进行hash显得有点蠢（set本身是基于dict的，也不支持对list这种“可变”结构进行hash），对tuple哈希倒是可以，总觉得背离了题目的本意，如果数据给一百万个同样的数字，会浪费大量的时间去判重。

​        典型的错误优化思路就是直接把输入序列去重，转换为set，然后每次向下递归的时候，可以重复使用元素。（这个思路显然是不行的，因为元素的个数是一个很重要的信息，不可能丢掉的，使用次数会超过上限）

​        所以最终还是用第一个想法，老老实实转成tuple放进set里面hash一下去重。效率确实不高，23％/100％

【学习】因为这道题我详细了解了一下python里面tuple、set、list、dict的关系，发现后三者是不能放进set的，因为他们的内容是可变的，而tuple的内容是不可变的（就像constant一样），不可变才是hashable的。



**T41****首个消失的正整数****(First Missing Positive) //python3**

【思路】想了一下，这题感觉没办法取巧，只能从1开始尝试，关键是判断是否存在的时候hash一下。python的set查询是用了dict的，也就将它本来就做了很好的hash（red-black tree)。那么直接翻译就行了

【疑问】C++STL应该也是集成了set或者dict的？那这题为什么算hard？我寻思就是自己手写hash也并不困难啊。而且在discussion里面我居然发现有人，，，直接用list写了个N^2的也过了？python的list查询应该是没有用红黑树吧，，，难道python3改了？我吐了



**T46****排列****(Permutations) //python3**

【思路】当然是递归，全排列应该只能用递归做，毕竟自带n阶乘的复杂度。让我觉得困难的地方在于定义什么参数？用什么方法来储存答案？

【注意】python的许多自带函数都是对自身进行操作的（准确来讲叫过程？），很多时候需要不改变自身而幅值给别人的话需要注意

【发现】python的OOP原理和C++几乎一模一样，像这道题，我发现在Solution类里定义一个变量，然后用加一个初始化函数，在一个类里都能用，猜想应该是默认public的吧。



**T47****排列二****(Permutations 2) //python3**

【思路】本着不重复造轮子的原则把上道题的代码粘贴过来，循环的时候注意重复的元素不进行递归调用，定义一个集合来判别重复即可。



**T48****旋转图像****(Rotate Image) //python3**

【思路】四个数的置换，本题强调原地操作，还是很有意思的。



**T49****相同字母异序词****(Group Anagrams) //python3**

【思路】Hash，这题我尝试了自己的想法，卡时间过：将字母的ASCII值加上一个大质数，然后相乘，作为哈希值。如果不加这个大质数，最后一个点会过不掉，因为26个字母的ASCII值并不互质，总是会出一些问题。

【借鉴】别人的代码，正规哈希

```python
class Solution(object):

    def groupAnagrams(self, strs):
        """ 
        :type strs: List[str]
        :rtype: List[List[str]]
        """ 

        anagram_hash = {}
        anagram_list = []

        for s in strs: 
            if "".join(sorted(s)) in anagram_hash:
                anagram_hash["".join(sorted(s))].append(s)
            else:
                anagram_hash["".join(sorted(s))] = []
                anagram_hash["".join(sorted(s))].append(s)

        for k, v in anagram_hash.items(): 
            anagram_list.append(v)

        return anagram_list
```



**T50****快速幂****(Pow(x,n)) //python3**

【思路】英语翻译

【启示】人生苦短，我用python（真就拒绝重复造轮子呗）



**T121 买卖股票的最佳时机 //python3**

【思路】其实像这种题，虽然是最简单的，但它确确实实有动态规划的思想在里面。倒着往回记录一遍当前时间抛售后可以享受的最高售价，然后正着扫描一遍就行了（写思路的时候我发现干嘛还要正着扫描？倒着推的时候就做了不行吗？我吐了）



**T322 数字转换为十六进制数 //python3**

【思路】第一想法递归（毕竟这题刚学递归的时候我做过），然后就陷入了减法的坑，调了半天都是超时。因为硬币可以用很多次，所以应该用乘法来递归，其实感觉借鉴了动规的思路。

【借鉴】不超时的关键在剪纸，有点像分支界定法的优化思路，先计算可能的最大值，然后凡是当前递归下去要超过当前最大值的都剪掉，更新最大值。

本题可以使用动态规划求解，可以参考LeetCode官方文档。我能想到的思路是借鉴完全背包，理论上来说可以用一维动规求解。



**T405** **数字转换为十六进制数** **//python3**

​    打表，位运算。不过这题有点奇怪的地方在于，int储存类型应该是自动完成补码运算的，负数与正数的处理手段应当是相同的。但是python里面这个右移似乎在碰到符号位的时候会出一点小毛病，所以我只能将32比特全部转换完，再去掉左侧连续零。它这个字符串函数可以说是非常强大了，s.strip（<char>）可以去掉两端指定字符，lstrip和rstrip可以去掉左端和右端指定字符，非常好用。

 

**T461** **汉明距离** **//python3**

^按位异或，&按位与，>>右移，<<左移



**T543 二叉树的直径 //python3**

【思路】等于左子树高度和右子树高度之和+2，我是回溯实现的，节省了不少时间（代价是内存仅仅超过了百分之10，多用了3Mb吧，以前很少出现这种情况，毕竟C出身写过板子的应该在用内存上都非常扣）。当然本题可以直接对每个节点都去计算左子树和右子树的高度之和，但感觉这样做的话意义不大。



**T657** **机器人能否回到原点** **//python3**

没啥好说的，s.count(<char>)是真的好用。



**T771珠宝和石头(Jewels and Stones) //C++**

这题没什么好说的，有点浪费时间。不需要Hash，直接索引就行了。4ms过了，看别人的代码有0ms过的，快在他用了STL里面的vector，不知道空间会不会省，但时间足够快。

 

**T832** **翻转图像** **//python3**

Python自带list里面就有reverse函数，可以逆序。这道题有个有意思的地方在于Python的机制，如果是C++，一个二重循环必然可以解决；但是Python似乎必须写两次循环。如果直接在对行枚举的循环里面执行取反操作会报错，我也不知道为什么。



**T1108 IP地址无效化 //python3**

首先学到的是python类中函数的定义，self是一个类似于C++中类指针this的东西，它的函数返回值的定义是在冒号前完成的，用-><类型>:来表示。

Python的字符串操作和MATLAB非常类似，len()可以直接得到字符串的长度，’+’可以连接两个字符串，可以直接用for i in range(len(s))来遍历字符串位数。



## 周赛题

### 2020/3/8

本周的比赛是在美服参加的，对应国服T5353和T5354

score: 7, time: 59:33, rank: 3051 / 6242

**T1374. Generate a String With Characters That Have Odd Counts //python3**

生成一个字符串，英语翻译

**T1375. Bulb Switcher III //python3**

简单模拟，这题我用set()去判断的，做了一点优化，没有超时也是很神奇

后来看别人的代码，直接判断第i次的时候最大值是不是i就行了，多简单

**回顾**

本次周赛题并不困难，第三题就是广度优先遍历一下树就可以了。但是我11点多才开始做这个比赛，又蠢到把BFS写错了= =。



## 后记

 LeetCode可能确实是网络上最简单的成年人oj，难度确实和ICPC什么的没法比，但是我始终觉得：把简单的东西做好就是不简单。在实际工作当中，可能连LeetCode-hard级别的问题也是很少遇到的，因而从功利的角度来说，LeetCode也许是工科狗的最好选择——毕竟大部分人这辈子都用不到AC自动机或者树状DP，甚至连FFT也不可能自己动手写一遍。

不管怎么说，闲暇时光写一写，总比开把游戏来得实惠些。