**T1****两数之和（****Two Sum****）****//C++**

简单来说题目就是输入序列和目标值，输出序列中满足和为目标值的两个数的位置。

学习以下几点：

①向量vector的使用，C++提供了一系列STL(Standard Template Library)即模板库，模板库包括容器、迭代器、空间配置器、配接器、算法、仿函数六个部分。本例中要使用的有<vector>和<map>。

【借鉴】②暴力思路很简单，注意枚举的时候三角形遍历，不要重复。基于目标值的哈希是很好的思路，可以把复杂度从O(n^2)降到O(m)。

③注意变量名和代码格式的规范性，数组索引命名当然应该用index



**T2****两数相加（****Add Two Numbers****）****//python3**

 对照他给定的ListNode的定义方式去写就好了，python这个if的写法真的是很英语了，多个变量同时赋值也非常的语言化，总的来说确实好用。

 

**T3****无重复最长子序列****(Longest Substring Without Repeating Characters) //C++**

这道题刷得比较艰难，在线调试没有一遍过，还是在线下编译调试了半天才发现三处问题。第一是需要注意length()函数返回的值和角标的关系：最后一个元素的角标是长度减1。平时不会在这上面犯错，但是出现循环条件判断的时候容易出错。第二处是本例有两种情况，元素直接入队、出队重复元素后入队，两种情况都要对入队元素的哈希进行修正，我一开始漏掉了后一种。第三处是直接复制粘贴导致的（发现第二个问题之后），把条件判断粘过来做赋值，直接导致赋值无效。

【思路】因为必须是连续的，所以扫描一遍就可以了，当入队的元素导致了重复时，队首元素出队直到不再重复。

 

**T4****两有序数组的中位数****(Median of Two Sorted Arrays) //C++**

思路来得很快，我的思路来自归并排序。这里需要先强调一下vector的用法，真的非常好用。

```
vector<int> a ;                              //声明一个int型向量a
vector<int> a(10) ;                         //声明一个初始大小为10的向量
vector<int> a(10, 1) ;                      //声明一个初始大小为10且初始值都为1的向量
vector<int> b(a) ;                           //声明并用向量a初始化向量b
vector<int> b(a.begin(), a.begin()+3) ;        //将a向量中从第0个到第2个(共3个)作为向量b的初始值
声明了向量之后，常用的操作有a.size()、a.empty()、a.clear()，还有神奇的b.swap(a)可以交换两个向量，非常好用。
```

二路归并的思路就是：设置两个指针，每次将两个指针对应的较小的数字归并，对应指针向后移动一步，如果有移动到头的指针，直接将另一路合并过来。寻找中位数的道理相同，分奇数偶数讨论即可。时间复杂度O(min(m+n))。需要注意的是leetcode不能另外开空间，它给定的数组长度是多少，就只能用这一片内存，再扩展的话会出问题。

【借鉴】本题可以优化到O(log(m+n))，思路来自两有序数组找第k小数问题。因为合并序列中必然有k-1个数小于等于k，假设这k-1个数有p个来自序列1，q个来自序列2，则必然满足如下条件：p+q=k-1；且这p+q个元素均小于第k小数。这样的话第p+1个和第q+1个数字中的较小值就是我们需要寻找的值。初始化p=q=(k-1)/2，如果第p个数小于第q个数，说明序列1中的数字都偏小了，全部舍弃，反之亦然。递归寻找第k-p或者第k-q小数，终止条件为：寻找第2小数（直接返回较小值）；p和q相等，返回后一位的较小值；较短序列到头，返回较长序列的k小数。



**T5****最长回文子串****(Longest Palindromic Substring) //python3**

【思路】分类讨论，串长可能是奇数/偶数，因为问题具有最优子结构（回文串去掉两头也是回文串）和无后效性，可以用DP的思路来解决，复杂度O(n^2)。需要注意的是本题还有一个分类讨论，就是串为空或者只有一个字母，一般来讲也能普适性的解决，但是实际操作的时候有可能会不对（比如串为单个字符的时候返回了空串）。

【借鉴】大致浏览了discussion里的思路，基本和我的想法一样，但是注意本题依然可以优化，https://blog.csdn.net/qq_17550379/article/details/84022674给出了Manacher算法的优化思路，类似的道理在KMP算法中也有应用。



**T6****之字转换****(ZigZag Conversion) //python3**

【借鉴】本题一方面学python里面list和字符串的定义与处理，与C甚至MATLAB等语言有很大不同。另一方面展示了一个问题可以怎样从另一个角度来思考，示例本身的格式可能会极大地影响对问题的解读，所以能否跳出示例所限制的条条框框就很关键——就像这道题，在草稿纸上画一个斜的“之”字，就很清晰了。



**T7****整数倒置****(Reverse of Integer) //C++**

主要要注意考虑全面，用long long来储存可能越界的数值并判断越界与否，需要注意的就是-maxlongint取绝对值之后是溢出的，操作数就应该直接用64位整型。



**T8****字符串转数字****(String to number atoi) //python3

【思路】打表

【注意】①python取区间是左闭右开的②corner condition优先考虑③python如果要去掉指定位置的字符，不要用replace直接置换指定字符，有可能把别的位置相同字符都置换掉了，.strip一样的道理

 

**T9****回文数****(Palindrome Number) //C++**

直接用T7的程序就行了，小于零直接返回0。另外可以加一句判断，如果这个数是10的整数倍，那就可以直接返回0；也可以尝试加更多剪枝语句，会略微快一点点。



**T10****正则表达式匹配****(Regular Expressing Matching) //python3

【借鉴】

方法一：递归（为了方便书写，*用#代替）

本题有明显的子结构，这是递归和动归思路来源的必要条件。比如讲abb和ab#是匹配的，如何判断出来呢？首要条件是a和a匹配，然后判断bb和b#是否匹配（问题的规模缩小了），都满足之后即证明两者匹配

递归边界（为什么讨论匹配串？因为模式串长度为零的时候匹配的匹配串可能还非常长！比如''和‘a#b#c#...’是匹配的）

1. 匹配串长度为零，此时除非模式串长度也为零，否则返回false
2. 匹配串长度为一（为什么边界一定要做两个？因为匹配串的长度可能是减一也可能是减二，并且后面涉及对第二位的判断，所以必须有一个长度为一的边界），此时除非模式串长度也为一，并且匹配（相等或者匹配串是'.'）

如何拆分成子问题呢？这里干扰视线的主要是#可能会让前缀字符重复很多次，如果匹配串中没有星号那么一切问题都很简单，所以容易想到的是：

1. 如果匹配串第二位不是#，那么模式串和匹配串首位相等的情况下（或者匹配串开头'.'），可以将问题等价为子问题（二者各自去掉首位后再比较）
2. 如果匹配串的第二位是#，首先要考虑的是，会不会匹配串这前两个都是无用字符？比如讲a和a#a，他们是匹配的，前提是把a#看做a重复零次，所以要检查（s，p[2:lenp]），同时，只要首位是match的，也可以缩减为子问题（即模式串去掉首位，匹配串去掉前两位），这里肯定要写一个循环来判断，因为不知道#能去掉模式串的多少个首位。注意到，ab和.#这个妖孽的例子也是满足这样的判断方式的（变成了空串的匹配），事实上.#似乎能表达一切式子……

【注意】

 

**T11****最能装水的容器****(Container With Most Water) //C++**

本题的关键在容器的高度由短板决定，从两边向中间枚举是容易想到的，在向中间枚举的过程中比两边更低的板子是可以直接忽略的（这也是容易想到的）。

【借鉴】优化到O(n)的关键在于只用移动短板，因为对于固定的短板而言，长板的那段向短板靠近只会得到更差的结果。所以在两边向中间枚举的过程中，只用将短板的一方向长板一方靠近，这样有可能会出现更优的解，不会遗漏最优解。

【思考】我觉得这提供了一种思维方式，贪心的过程中，可以思考怎样变化能够使得结果更好，对注定使结果更差的分支，可以直接剪掉，故可以思考怎样变化注定使结果变差。

 

**T12****阿拉伯数字转罗马数字****(Integer to Roman) //C++**

本题的关键麻烦在于4、9、40等这些特殊数字，如果讨论来解决非常麻烦。

【借鉴】直接打表，干脆将所有特殊数字打表，就迎刃而解。

 

**T13****罗马数字转阿拉伯数字（****Roman to Integer) //C++**

同样是打表，这次思路就很清楚，先对比两个连在一起的，再对比单字符的就可以了。

 

**T405** **数字转换为十六进制数** **//python**

​    打表，位运算。不过这题有点奇怪的地方在于，int储存类型应该是自动完成补码运算的，负数与正数的处理手段应当是相同的。但是python里面这个右移似乎在碰到符号位的时候会出一点小毛病，所以我只能将32比特全部转换完，再去掉左侧连续零。它这个字符串函数可以说是非常强大了，s.strip（<char>）可以去掉两端指定字符，lstrip和rstrip可以去掉左端和右端指定字符，非常好用。

 

**T461** **汉明距离** **//python**

^按位异或，&按位与，>>右移，<<左移



**T657** **机器人能否回到原点** **//python**

没啥好说的，s.count(<char>)是真的好用。



**T771****珠宝和石头****(Jewels and Stones) //C++**

这题没什么好说的，有点浪费时间。不需要Hash，直接索引就行了。4ms过了，看别人的代码有0ms过的，快在他用了STL里面的vector，不知道空间会不会省，但时间足够快。

 

**T832** **翻转图像** **//python**

Python自带list里面就有reverse函数，可以逆序。这道题有个有意思的地方在于Python的机制，如果是C++，一个二重循环必然可以解决；但是Python似乎必须写两次循环。如果直接在对行枚举的循环里面执行取反操作会报错，我也不知道为什么。



**T1108 IP****地址无效化** **//python**

首先学到的是python类中函数的定义，self是一个类似于C++中类指针this的东西，它的函数返回值的定义是在冒号前完成的，用-><类型>:来表示。

Python的字符串操作和MATLAB非常类似，len()可以直接得到字符串的长度，’+’可以连接两个字符串，可以直接用for i in range(len(s))来遍历字符串位数。

 
