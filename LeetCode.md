# LeetCode

[TOC]



## Daily-Practice

### T1~50

**T1两数之和（Two Sum）//C++**

【思路】输入序列和目标值，输出序列中满足和为目标值的两个数的位置。

【学习】

①向量vector的使用，C++提供了一系列STL(Standard Template Library)即模板库，模板库包括容器、迭代器、空间配置器、配接器、算法、仿函数六个部分。本例中要使用的有<vector>和<map>。

【借鉴】②暴力思路很简单，注意枚举的时候三角形遍历，不要重复。基于目标值的哈希是很好的思路，可以把复杂度从O(n^2)降到O(m)。

③注意变量名和代码格式的规范性，数组索引命名当然应该用index



**T2两数相加（Add Two Numbers）//python3**

 【思路】对照题目给定的ListNode的定义方式实现

【学习】本题参考别人的代码，熟悉python的一些可以提升代码可读性的操作，简单条件的If可以写在操作后，另外多个变量可以同时赋值。

 

**T3无重复最长子序列(Longest Substring Without Repeating Characters) //C++**

【思路】这道题刷得比较艰难，在线调试没有一遍过，还是在线下编译调试了半天才发现三处问题。第一是需要注意length()函数返回的值和角标的关系：最后一个元素的角标是长度减1。平时不会在这上面犯错，但是出现循环条件判断的时候容易出错。第二处是本例有两种情况，元素直接入队、出队重复元素后入队，两种情况都要对入队元素的哈希进行修正，我一开始漏掉了后一种。第三处是直接复制粘贴导致的（发现第二个问题之后），把条件判断粘过来做赋值，直接导致赋值无效。

【思路】因为必须是连续的，所以扫描一遍就可以了，当入队的元素导致了重复时，队首元素出队直到不再重复。

 

**T4两有序数组的中位数(Median of Two Sorted Arrays) //C++**

思路来得很快，我的思路来自归并排序。这里需要先强调一下vector的用法，真的非常好用。

```
vector<int> a ;                              //声明一个int型向量a
vector<int> a(10) ;                         //声明一个初始大小为10的向量
vector<int> a(10, 1) ;                      //声明一个初始大小为10且初始值都为1的向量
vector<int> b(a) ;                           //声明并用向量a初始化向量b
vector<int> b(a.begin(), a.begin()+3) ;        //将a向量中从第0个到第2个(共3个)作为向量b的初始值
声明了向量之后，常用的操作有a.size()、a.empty()、a.clear()，还有神奇的b.swap(a)可以交换两个向量，非常好用。
```

二路归并的思路就是：设置两个指针，每次将两个指针对应的较小的数字归并，对应指针向后移动一步，如果有移动到头的指针，直接将另一路合并过来。寻找中位数的道理相同，分奇数偶数讨论即可。时间复杂度O(min(m+n))。需要注意的是leetcode不能另外开空间，它给定的数组长度是多少，就只能用这一片内存，再扩展的话会出问题。

【借鉴】本题可以优化到O(log(m+n))，思路来自两有序数组找第k小数问题。因为合并序列中必然有k-1个数小于等于k，假设这k-1个数有p个来自序列1，q个来自序列2，则必然满足如下条件：p+q=k-1；且这p+q个元素均小于第k小数。这样的话第p+1个和第q+1个数字中的较小值就是我们需要寻找的值。初始化p=q=(k-1)/2，如果第p个数小于第q个数，说明序列1中的数字都偏小了，全部舍弃，反之亦然。递归寻找第k-p或者第k-q小数，终止条件为：寻找第2小数（直接返回较小值）；p和q相等，返回后一位的较小值；较短序列到头，返回较长序列的k小数。



**T5最长回文子串(Longest Palindromic Substring) //python3**

【思路】分类讨论，串长可能是奇数/偶数，因为问题具有最优子结构（回文串去掉两头也是回文串）和无后效性，可以用DP的思路来解决，复杂度O(n^2)。需要注意的是本题还有一个分类讨论，就是串为空或者只有一个字母，一般来讲也能普适性的解决，但是实际操作的时候有可能会不对（比如串为单个字符的时候返回了空串）。

【借鉴】大致浏览了discussion里的思路，基本和我的想法一样，但是注意本题依然可以优化，https://blog.csdn.net/qq_17550379/article/details/84022674  给出了Manacher算法的优化思路，类似的道理在KMP算法中也有应用。



**T6之字转换(ZigZag Conversion) //python3**

【借鉴】本题一方面学python里面list和字符串的定义与处理，与C甚至MATLAB等语言有很大不同。另一方面展示了一个问题可以怎样从另一个角度来思考，示例本身的格式可能会极大地影响对问题的解读，所以能否跳出示例所限制的条条框框就很关键——就像这道题，在草稿纸上画一个斜的“之”字，就很清晰了。



**T7整数倒置(Reverse of Integer) //C++**

主要要注意考虑全面，用long long来储存可能越界的数值并判断越界与否，需要注意的就是-maxlongint取绝对值之后是溢出的，操作数就应该直接用64位整型。



**T8字符串转数字(String to number atoi) //python3**

【思路】打表

【注意】①python取区间是左闭右开的②corner condition优先考虑③python如果要去掉指定位置的字符，不要用replace直接置换指定字符，有可能把别的位置相同字符都置换掉了，.strip一样的道理

 

**T9回文数(Palindrome Number) //C++**

直接用T7的程序就行了，小于零直接返回0。另外可以加一句判断，如果这个数是10的整数倍，那就可以直接返回0；也可以尝试加更多剪枝语句，会略微快一点点。



**T10正则表达式匹配(Regular Expressing Matching) //python3**

【借鉴】

方法一：递归（为了方便书写，*用#代替）

本题有明显的子结构，这是递归和动归思路来源的必要条件。比如讲abb和ab#是匹配的，如何判断出来呢？首要条件是a和a匹配，然后判断bb和b#是否匹配（问题的规模缩小了），都满足之后即证明两者匹配

递归边界（为什么讨论匹配串？因为模式串长度为零的时候匹配的匹配串可能还非常长！比如''和‘a#b#c#...’是匹配的）

1. 匹配串长度为零，此时除非模式串长度也为零，否则返回false
2. 匹配串长度为一（为什么边界一定要做两个？因为匹配串的长度可能是减一也可能是减二，并且后面涉及对第二位的判断，所以必须有一个长度为一的边界），此时除非模式串长度也为一，并且匹配（相等或者匹配串是'.'）

如何拆分成子问题呢？这里干扰视线的主要是#可能会让前缀字符重复很多次，如果匹配串中没有星号那么一切问题都很简单，所以容易想到的是：

1. 如果匹配串第二位不是#，那么模式串和匹配串首位相等的情况下（或者匹配串开头'.'），可以将问题等价为子问题（二者各自去掉首位后再比较）
2. 如果匹配串的第二位是#，首先要考虑的是，会不会匹配串这前两个都是无用字符？比如讲a和a#a，他们是匹配的，前提是把a#看做a重复零次，所以要检查（s，p[2:lenp]），同时，只要首位是match的，也可以缩减为子问题（即模式串去掉首位，匹配串去掉前两位），这里肯定要写一个循环来判断，因为不知道#能去掉模式串的多少个首位。注意到，ab和.#这个妖孽的例子也是满足这样的判断方式的（变成了空串的匹配），事实上.#似乎能表达一切式子……

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        return ismatching(s,p)
def ismatching(s: str, p: str) -> bool:
    lens=len(s)
    lenp=len(p)
    if lenp==0:
        return lens==0
    if lenp==1:
        return (lens==1) and (p[0]==s[0] or p[0]=='.')
    if p[1]!="*":
        if lens==0:
            return 0
        else:
            return (s[0]==p[0] or p[0]==".") and (ismatching(s[1:lens],p[1:lenp]))
    else:
        while(len(s)>0 and (p[0]==s[0] or p[0]==".")):
            if ismatching(s,p[2:lenp]):
                return 1
            s=s[1:len(s)]
        return (ismatching(s,p[2:lenp]))
```

【思路】

方法二：DP（DP是模仿递归自己推的，感觉非常不简洁）

发现递归的思路重复计算了很多计算过的自问题，所以觉得应该可以改成递推的形式

从后向前推，设定i表示当前模式串串长度，j表示匹配串长度，dp[i,j]记录布尔值

边界条件dp[0,0]=1，dp[1,1]=最后一位是否匹配，其余j=0/1的部分全部置零

二重循环递推，讨论当前匹配串的第二位是不是*

1.  如果不是，dp[i,j]= false if not i（防止匹配串长度为零）first index match and dp[i-1,j-1]
2.  如果是，dp[i,j]=1 if dp[i,j-2]==1。模仿递归的思路，这里可初始化k为i，当当前模式串的首位和匹配串可以匹配时，k可以递减，以此模拟#重复表示多个符号的情况



**T11最能装水的容器(Container With Most Water) //C++**

本题的关键在容器的高度由短板决定，从两边向中间枚举是容易想到的，在向中间枚举的过程中比两边更低的板子是可以直接忽略的（这也是容易想到的）。

【借鉴】优化到O(n)的关键在于只用移动短板，因为对于固定的短板而言，长板的那段向短板靠近只会得到更差的结果（为什么？因为容器能装多少水是由短板决定的！两边都只能变长的情况下动长板毫无意义，所以要增加容量应该是找到两个尽可能远的长板，优化的对象永远是相对短的那一个）。所以在两边向中间枚举的过程中，只用将短板的一方向长板一方靠近，这样有可能会出现更优的解，不会遗漏最优解。

【思考】我觉得这提供了一种思维方式，贪心的过程中，可以思考怎样变化能够使得结果更好，对注定使结果更差的分支，可以直接剪掉，故可以思考怎样变化注定使结果变差。

 

**T12阿拉伯数字转罗马数字(Integer to Roman) //C++**

本题的关键麻烦在于4、9、40等这些特殊数字，如果讨论来解决非常麻烦。

【借鉴】直接打表，干脆将所有特殊数字打表，就迎刃而解。

 

**T13罗马数字转阿拉伯数字(Roman to Integer) //C++**

同样是打表，这次思路就很清楚，先对比两个连在一起的，再对比单字符的就可以了。



**T14最长公共前缀(Longgest Common Prefix) //python3**

找到最短的那个，从头开始逐字符判断即可

【注意】本题是典型的反面判据：为了代码的简单性，我设置的是一旦发现不同就退出，由于是二重循环，需要设置一个flag变量break两次，外层的break一定要写在内层循环之后，否则很容易出现问题。



**T15三数之和(3 Sum) //python3**

【思路】由于样例中给出的三元组都是有序的，所以显然应该先对输入序列排序。本题至少应该优化到N^2，所以排序的复杂度可以不计。设置三个指针变量，i、j、k，代表三个数在数组中位置，如果i从开始向末端移动，那么j从i+1的位置向末端移动，由于nums是有序的，对同一个i而言，k只需要从nums的末端扫描到j+1的位置即可。
优化的关键在于，如果nums[i]和num[i-1]一样的话，直接continue就好了，因为如果nums[i]==nums[i-1]，由num[i]计算出的结果必然是num[i-1]的子集。



**T16三数之和最近(3 Sum Closest) //python3**

【思路】和上面一模一样，计算误差，对每个i，k只向一个方向移动，移动到对当前j来说误差最小的位置。如果对j来说这个k是最好的，那么对j+1来说，更好的k不可能向右移动！因为向右只会让误差更大。



**T17电话号码字母组合(Letter Combinations of a Phone number) //python3**

【思路】检讨，我第一反应居然是递归。这根本没有必要递归的，递归是自己浪费系统堆栈。自己拿一个list把结果存起来，从1个字母推到n个字母就好了，每一步把上一步的结果从list里面删掉

【注意】如果要用remove删，删len（上次的len）次ans[0]就行了，千万别删每次去删ans[j]，依次执行会出问题的



**T18四数之和(4 Sum) //python3**

【思路】照搬3数和的思路，马马虎虎凑了个N三方的程序怼过去了，还不错，如果按有序性break的话，如果target正常其实勉强算常数比较大的N平方？

【借鉴】其实计算并储存两数之和然后用字典检索就好了，可以优化到N平方的，不过我懒，不想写这个代码了



**T19去除链表倒数N位数(Remove Nth Node from End of List) //python3**

【思路】模拟

【注意】要细心，设计链表的题，注意头结点的处理。另外corner conditon：输入的链表只有一个元素怎么办？



**T20有效括号(Valid Parentheses) //python3**

【思路】栈

【注意】空栈单独判断



**T21合并有序链表(Merge Two Sorted Lists) //python3**

【思路】模拟

【注意】注意新结点要调用构造函数生成



**T22生产括号(Generate Parenthese) //python3**

【思路】栈混洗，Catalan数，递归生成即可

【注意】我尝试了将ans放在全局变量，发现它似乎会随着测试数据的更迭而变化（append的话会把上一个数据的结果也保存下来，所以最好不要放全局）。

【补充】这和C++的类与对象是一样的。LeetCode的题解调用的是一个类为Solution的对象中的特定函数，所以不要把变量或者结果定义为全局变量（如果非要的话，在被调用函数的内部初始化）。如果把变量或结果定义为类的一个属性，也要注意在调用的那个函数的时候初始化（我没有试过构造函数，也许可以吧）。

【补充思路】反正是遍历最终ans树的所有叶子结点，广搜当然也可以，第二遍做是在每日一题，写了一遍广搜。从实际执行结果来看，效率不如深搜，可能原因是list的插入和保存时间效率不高，不如系统栈的实现。



**T23合并k个排序链表 //python3**

【思路】

解法1：分治，按归并排序的思路来是最容易想到的办法，基础操作是双链表的合并。

解法2：优先队列，将k个链表的表头元素维护成一个小头堆，堆顶出队，对应链表的next入队。注意python3有queue模块，这个代码是从力扣的官方解答中拔出来的，当然我做了小的改动。python原版本引用模块是Queue，注意Q大写，另外加入优先队列的元组中可以有链表。python3好像不能加入含有链表的元组，所以我改成了链表序号k。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

from queue import PriorityQueue

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if lists == []:
            return []
        head = point = ListNode(0)
        q = PriorityQueue()
        for k in range(len(lists)):
            if lists[k]:
                q.put((lists[k].val, k))
        while not q.empty():
            val, num = q.get()
            point.next = ListNode(val)
            point = point.next
            hh = lists[num]
            tmp = hh.next
            lists[num] = tmp
            if lists[num]:
                q.put((lists[num].val, num))
        return head.next
```



**T24 两两交换链表中的节点**

【思路】考察对链表和指针的理解，python的链表相对C而言人性化了很多，操作起来还是比较方便的。



**T25 k个一组翻转链表**

【思路1】

模仿上一题，储存头结点、下一个头结点，从后向前依次将结点指向上一个结点，时间复杂度O(nk)，空降复杂度O(1)，完全符合要求，虽然时间复杂度略高，但只用了3个临时结点和一个哨兵结点，空间复杂度为常数

【借鉴思路2】

用栈来储存结点，依次入队后出队反转，注意头结点之间的衔接即可。时间复杂度O(n)，空间复杂度O(k)，不过，这种解法其实并不符合题意，空间复杂度过高。

【借鉴思路3】

和思路1一样，不过特殊之处在于，其实思路1翻转链表的方式挺蠢的。翻转链表有非常简单的方式（莫名感觉像辗转相除或者原地操作的斐波那契？）：

```java
	public ListNode reverseList(ListNode head) {
		ListNode pre = null;
		ListNode cur = head;
		ListNode tmp = null;
		while(cur!=null) {
			tmp = cur.next;
			cur.next = pre;
			pre = cur;
			cur = tmp;
		}
		return pre;
	}
```



**T26 有序列表去重(Remove Duplicates from Sorted Array) //python3**

【思路】模拟

【注意】时刻注意下表是否越界



**T27 去除元素(Remove Element) //python3**

【思路】模拟

【注意】时刻注意下表是否越界



**T28实现 strStr()(Inplement strStr()) //python3**

【思路】模拟，人生苦短我用python，python的字符串集成了.find函数，重载了查找字符串的功能！



**T29两数相除(Divide Two Intergers) //python3**

【批评】本题相当无趣，主要是负数情况的讨论，非常boring



**T31下一个排列 //python3**

这题我写得浑身难受，要注意的地方有点多，它又要求原地操作，浑身难受。

【思路】下一个排列是什么？是先找到包含末尾的连续的下降序列，然后将下降序列的前一个数字，和下降序列中刚好比它大的数字，进行交换，交换后对原下降序列位置上的所有数字逆序。

【注意】何谓下降序列？这是一个不要求严格下降的序列，等于也是可以的。但是交换的时候，要求严格大于。

【思考】关于这个机理需要进一步思考，为什么这样能得到字典序恰好更大一点点的序列？



**T32 最长有效括号 //python3**

【借鉴】动态规划，首先注意它必须是连续的括号，如果不要是连续括号的话，其实非常简单。连续有效括号的动规思路如下：

设定dp[i]表示以第i位结尾（必须包含i）的最长有效括号，初始化所有左括号位置的dp为零。【分类讨论】如果是右括号，'))'和'()'的形式分开讨论，'))'要前推上一个右括号的最长有效括号数，看看前面是不是'('，如果是，在上一个基础上加2。'()'就简单了，在前两个基础上加2就好了。



**T33 搜索旋转排序数组 //python3**

【思路】因为之前做过了旋转排序数组旋转点（对升序序列而言是最小值）查找的程序，所以本题思路非常明了，先找出旋转点，然后分段进行二分查找

【补记】附上的代码写复杂了，因为仅从大小就可以判断target在哪一段中。



**T34 在排序数组中查找元素的第一个和最后一个位置 //python3**

【思路】二分查找变形，关键在二分的时候大于小于号带不带等号，对于一般查找，等于即可返回。对这种问题，找左边开头数字的话，如果target<=nums[mid]返回左边，否则返回右边。找右边开头数字的话，如果target>=nums[mid]返回右边，否则返回左边。

【注意】现在写此类代码已经形成习惯，如果r-l小于一定值直接使用枚举法查找，理论上来说可以提升性能，也能避免递归边界是l==r还是l==r-1的问题。



**T35 寻找插入位置(Search Insert Position) //python3**

【思路】分治法，cornor condition是输入空列表



**T36 有效的数独 //python3**

【思路】纯模拟，之前在CodeWar上做过。



**T37 解数独 //python3**

【反思】我现在写一个回溯如此吃力 = = 是该正视自己的水平了，太菜了

1. 第一次犯错误，是在擦除的时候，这个时候不能返回False的，要让循环继续跑。写回溯一定要思路清晰。然后就是，先判断再修改，我一开始直接改map，如果不行又忘了擦，我是怎么想的呢：如果不行会被下一个覆盖，如果都不行会调用上一个。但是这个位置被最后一次循环填了，又没有调用下一层，没地方擦它，就出问题了。
2. 第二次改对了，提交却超时，为什么呢？因为判断是否合理写得太蠢了。每次填入一个数字，并不需要对全体数独都判断一下，只需要判断填入的这一行、一列、一块就行了，其他的肯定都是对的，重复判断必然超时。



**T38 数数(Count and Say) //python3**

【思路】递推，能不用递归尽量不用，想了半天发现实在是没有使用递归的必要性。



**T39 组合之和(Combination Sum) //python3**

【思路】本题子结构十分明显，最自然也最合理的思路只能是递归。

【注意】

1. 像这道题，为了节约内存，我已经尽可能地减少递归调用的参数了，需要注意的是（再次强调），保存在对象初始化时的ans，那个ans在被调用的类函数中要做初始化，不然每个样例的结果会在里面累加。。。
2. append实在是一个不太好用的函数，说实话我写python到现在觉得方便是方便，但这功能确实有点冗余（对于list的append函数来讲），因为append是对自身的一个过程，在递归调用的时候经常把list.append()当成一个列表（然而其实返回值是None），还不如直接list+[new element]来得舒服。。。

【思考】我这个解法完全没有优化也干掉了82%/100％，因为排了序，所以查找的时候可以用二分查找的，还可以优化。内存也是，可以思考能不能不把历史存在递归的参数中，回溯得到结果可以吗？



**T40组合之和2(Combination Sum 2) //python3**

【思路】想把上一题的代码直接搬过来。思考了一下发现肯定不行，因为如果有重复元素的话，肯定会出现重复组合。所以最开始的想法是，照搬上题代码，加一个hash。但是对列表进行hash显得有点蠢（set本身是基于dict的，也不支持对list这种“可变”结构进行hash），对tuple哈希倒是可以，总觉得背离了题目的本意，如果数据给一百万个同样的数字，会浪费大量的时间去判重。

​        典型的错误优化思路就是直接把输入序列去重，转换为set，然后每次向下递归的时候，可以重复使用元素。（这个思路显然是不行的，因为元素的个数是一个很重要的信息，不可能丢掉的，使用次数会超过上限）

​        所以最终还是用第一个想法，老老实实转成tuple放进set里面hash一下去重。效率确实不高，23％/100％

【学习】因为这道题我详细了解了一下python里面tuple、set、list、dict的关系，发现后三者是不能放进set的，因为他们的内容是可变的，而tuple的内容是不可变的（就像constant一样），不可变才是hashable的。



**T41首个消失的正整数(First Missing Positive) //python3**

【思路】这题感觉没办法取巧，只能从1开始尝试，关键是判断是否存在的时候hash一下。python的set查询是用了dict的，也就将它本来就做了很好的hash（用的是red-black tree)。那么直接翻译就行了

【疑问】C++STL应该也是集成了set或者dict的？那这题为什么算hard？我寻思就是自己手写hash也并不困难啊。而且在discussion里面我居然发现有人，，，直接用list写了个N^2的也过了？python的list查询应该是没有用红黑树吧，，，难道python3改了？不明白。



**T43 字符串相乘**

【思路】大整数乘法，这题让我感觉我确实老了，写个高精度错了两遍。第一遍没考虑一个乘数为零的情况下会输出大量前导零，第二遍debug的时候没考虑零作为乘数结果也是零（如果去零的话会全部抹掉），同时每个数字应该在大于9的情况下模十，而不是大于10，，，



**T45 跳跃游戏二 //python3**

【思路】贪心，第k步的区间是l~r，然后第k+1步的区间是r+1~max(r+1,i+nums[i])，其中i~[l,r]，只要这个区间越过了（包含）len(nums)-1，即为当前最优步数。

【注意】本题还蛮简单的，注意一下cornor condition即可，输入为空、长度为1都是直接返回0的。



**T46排列(Permutations) //python3**

【思路】当然是递归，全排列应该只能用递归做，毕竟自带n阶乘的复杂度。让我觉得困难的地方在于定义什么参数？用什么方法来储存答案？

【注意】python的许多自带函数都是对自身进行操作的（准确来讲叫过程？），很多时候需要不改变自身而幅值给别人的话需要注意

【发现】python的OOP原理和C++几乎一模一样，像这道题，我发现在Solution类里定义一个变量，然后用加一个初始化函数，在一个类里都能用，应该是默认public的吧。

【更新】每日一题重复了，用回溯重写一遍，效率反而变低了？不过倒是熟悉了python变量拷贝的问题



**T47排列二(Permutations 2) //python3**

【思路】本着不重复造轮子的原则把上道题的代码粘贴过来，循环的时候注意重复的元素不进行递归调用，定义一个集合来判别重复即可。



**T48旋转图像(Rotate Image) //python3**

【思路】四个数的置换，本题强调原地操作，还是很有意思的。



**T49相同字母异序词(Group Anagrams) //python3**

【思路】Hash，这题我尝试了自己的想法，卡时间过：将字母的ASCII值加上一个大质数，然后相乘，作为哈希值。如果不加这个大质数，最后一个点会过不掉，因为26个字母的ASCII值并不互质，总是会出一些问题。

【借鉴】别人的代码，正规哈希

```python
class Solution(object):

    def groupAnagrams(self, strs):
        """ 
        :type strs: List[str]
        :rtype: List[List[str]]
        """ 

        anagram_hash = {}
        anagram_list = []

        for s in strs: 
            if "".join(sorted(s)) in anagram_hash:
                anagram_hash["".join(sorted(s))].append(s)
            else:
                anagram_hash["".join(sorted(s))] = []
                anagram_hash["".join(sorted(s))].append(s)

        for k, v in anagram_hash.items(): 
            anagram_list.append(v)

        return anagram_list
```



**T50快速幂(Pow(x,n)) //python3**

【思路】英语翻译

【启示】人生苦短，我用python（真就拒绝重复造轮子呗）



### T50~100

**T51 N皇后 //python3**

【思路】回溯，太经典了



**T52 N皇后2 //python3**

【思路】同上



**T53 最大子序和 //python3**

【思路】

解法1：类似于动规，递推过去就好，有明显的子结构，O(n)

解法2：分治，O(log(n))，不断二分，合并的时候要判断两个分段的最大子序是不是连在一起的。如果不是，还要分类讨论（**没有写代码**）



**T54 螺旋矩阵 //python3**

【思路】归纳分析+比较复杂的模拟操作，设置四个方向向量，用模运算来实现周期为4的循环，转到无路可走的时候退出。



**T55 跳跃游戏 //python3**

【思路】不知道为什么，跳跃游戏2反而在前面，但是两道题本质是一样的，贪心思路可以完美解决。



**T56 合并区间 //python3**

【思路】对区间进行排序，然后依次合并。由于排过序，所以只需要判断当前最后一个已经合并的区间，右端是否落在未合并区间左侧之右，如果是，说明重叠，进行合并，合并左侧为已经合并区间的左侧，右侧为两个区间右侧的较大值。



**T58 最后一个单词的长度 //python3**

【思路】模拟



**T66 加一 //python3**

【思路】高精度的基本操作，注意首位的进位。



**T67 二进制求和 //python3**

【思路】模拟

【借鉴】人生苦短我用python

```python
class Solution:
    def addBinary(self, a, b) -> str:
        return '{0:b}'.format(int(a, 2) + int(b, 2))
```



**T69 x的平方根**

【思路】不太想直接开根号，所以我用的是牛顿拉夫逊迭代，然后注意了一下量化误差。

【注意】这题的题解区非常精彩，八仙过海各显神通。



**T70 爬楼梯**

【思路】两步递推，最优解法应该是矩阵快速幂了。不过从提交结果来看也不算快，应该是数据量不大。



**T98 验证二叉搜索树**

【借鉴】BST判断应该最好是用中序遍历，这里写在总结里面了，它实现中序遍历的方法还是很骚气的



### T100~300

**T102 二叉树的层序遍历 //python3**

【思路】类似于一个广搜的过程，直接BFS即可



**T108 将有序数组转换为二叉搜索树 //python3**

【思路】要求是平衡的，所以指定中点作为根节点即可。按照题目意思递归实现。



**T118 杨辉三角 //python3**

【思路】递推就好



**T121 买卖股票的最佳时机 //python3**

【思路】本题虽然简单，但它确确实实有动态规划的思想在里面。倒着往回记录一遍当前时间抛售后可以享受的最高售价，然后正着扫描一遍就行了（其实不用正着扫描，倒着推的时候就可以做了，补记）



**T136 只出现一次的数字 //python3**

【思路】异或，这题的延伸版是面试题56-1



**T151 翻转字符串里的单词 //python3**

【思路】s.split()，s.reverse()，''.join(s)。军体拳三连。



**T153 寻找旋转排序数组中的最小值 //python3**

【思路】二分法，由于没有重复元素，中间值大于最右值的话说明在右边，中间值小于最右值的话说明在左边。



**T154 寻找旋转排序数组中的最小值 //python3**

【思路】和上道题一样，但是由于元素可重复，中间值有可能等于右边，此时无法判断最小值在哪边。那怎么办？一种思路是两边分别再二分，然后取较小值。我的思路比较暴力，如果中间的等于右边，那说明至少有一半以上的相同元素，这种极端情况已经接近O(N)了，既然这样，遇到这种情况直接暴搜就好了。



**T155 最小栈 //python3**

【思路】注意，在初始化函数里要这样定义：

```python
def __init__(self):
    self.stack = []
```

这个地方self指针要带上，不然类中其他成员不认识这个stack。别的没什么好说的，注意list.pop()返回的是pop的值，同时也会把list列表里面的元素抹去。



**T167 两数之和二 - 输入有序数组 //python3**

【思路】双指针典型例题，快慢指针



**T169 多数元素 //python3**

【思路】模拟



**T198 打家劫舍 //python3**

【思路】由于每日一题的存在，我先做的面试题17.16按摩师（这名字怎么这么sq），跟本题一模一样。



**T199 二叉树的右视图 //python3**

【思路】广度优先搜索。也就是层序遍历，然后返回每层的最右侧值即可

【借鉴】思路有点僵化，可以右子结点先入队，然后就不用算长度了



**T200 岛屿数量 //python3**

【思路】广搜入门题。

【注意】本题我犯了两次错误。本来说起来广搜写起来应该很熟练了才对，结果总是犯奇怪的错误。首先是是注意输入格式，本题输入的是字符列表，不是数字；然后就是循环变量的问题，python没有提示循环内部已经改变循环变量的，我特别喜欢用dx和dy这样的4/8位循环来表示城际/8块距离，内循环写的时候注意有没有用外循环的变量。



**T202 快乐数 //python3**

【思路】循环判断，模拟

【借鉴】这道题最有意思的地方在于如何判断判断多少次，它很重要的一个思维是判断转化的收敛性，看样例很容易就会觉得，平方和是越来越大的。但其实对大数来讲，它各位平方和会收缩到一个非常小的数字上。

【注意】python的set()真的是超级强了，这题我设想了一个比较巧妙的hashmap，并针对特定情况进行了优化，结果却是毫无变化。



**T221 最大正方形 //python3**

【思路】很容易想到动态规划，以右下角为记录点

【借鉴】它的动态方程还是很巧妙的，dp[i,j] = min(dp[i,j-1],dp[i-1,j],dp[i-1,j-1])+1

【注意】cornor condition，又被这个坑了，如果只有一个数或者一行、一列或者除这些之外都是零，动规实际上不推，这时候该输出什么就要看情况了。所以一开始就要判断第一行第一列有没有1，有1的话MAX设置成1。



**T300 最长上升子序列 //python3**

【思路】DP经典思路，以dp[i]记录以第i位结尾（必须包含第i位）的最长子序列长度，那么显然，需要枚举N^2次，找到其之前小于第i位数字结尾的所有dp中最大的那个，加1就是dp[i]

【想法】DP的效率肯定不是最优的，本题有更优的分治算法。另外注意对比这种“子序列”和连续子序列的区别



### T300~600

**T322 零钱兑换 //python3**

【思路】第一想法递归（毕竟这题刚学递归的时候我做过），然后就陷入了减法的坑，调了半天都是超时。因为硬币可以用很多次，所以应该用乘法来递归，其实感觉借鉴了动规的思路。

【借鉴】不超时的关键在剪枝，有点像分支界定法的优化思路，先计算可能的最大值，然后凡是当前递归下去要超过当前最大值的都剪掉，更新最大值。

本题可以使用动态规划求解，可以参考LeetCode官方文档。我能想到的思路是借鉴完全背包，理论上来说可以用一维动规求解。



**T344 反转字符串 //python3**

【思路】人生苦短



**T365 水壶问题 //python3**

【思路】这道题我非常熟悉，一是因为以前做过，二是因为太阁立志传5的医学小游戏就是类似的模式。不过本题的环境不同于那个小游戏，因为如果min(x,y)<z，返回的结果一定是False。换言之，最终的结果不是一个单独可容纳水的“壶”，而是一个定量，这个定量必须用给定的两个筒做出来。

然后就是数学问题了，本题可以建模为mx+ny = z，求解这个方程。这是一个两变量的丢番图方程，是否有解可以用裴蜀定理（贝祖定理）来解决。结果是z%(gcd(x,y))==0。特别来说，mx+ny=1，当且仅当x和y互素时有解（等价关系，充分必要条件）。后面贴上我惯用的GCD函数，感觉还是比较简洁的。

【借鉴】当然，搜索可以解决一切问题，本题可以用深度/广度优先搜索解决。

```python
def gcd(a:int,b:int)->int:
	return gcd(b,a%b) if b else a
```



**T378 有序矩阵中第K小的元素**

【思路】优先队列，因为一个数一定小于其右边和下边的数字，所以在它出队之前，它的右边和下边都不需要入队。当它出队后，再将一定比它大的数字入队。如此一来，从左上角开始入队，维护一个优先队列，第k个出队的就是我们要找的值。

【借鉴】这里有二分查找的方法，可以对矩阵进行划分，非常秀。



**T405** **数字转换为十六进制数** **//python3**

​    打表，位运算。不过这题有点奇怪的地方在于，int储存类型应该是自动完成补码运算的，负数与正数的处理手段应当是相同的。但是python里面这个右移似乎在碰到符号位的时候会出一点小毛病，所以我只能将32比特全部转换完，再去掉左侧连续零。它这个字符串函数可以说是非常强大了，s.strip（<char>）可以去掉两端指定字符，lstrip和rstrip可以去掉左端和右端指定字符，非常好用。



**T409 最长回文子串 //python3**

本题在借鉴了错误样例检测的情况下思路依然错了两次。

犯了很多想当然的错误。由于可以从字符串中随意挑选字符，所以尽可能多地每种字符都拿偶数个。对数量为奇数个的字符，最多的放中间，较少的减一个拿偶数个出来即可。当然如果没有奇数个的，直接求和就行了。

所以最终的公式应该是：sum(count_even+count_odd)-if(num_odd>0)



**T445 两数相加2 //python3**

【思路】链表转高精度，高精度相加，高精度转链表。python3集成了高精度，就非常任性了。

 

**T461** **汉明距离** **//python3**

^按位异或，&按位与，>>右移，<<左移



**T498 对角线遍历 //python3**

【思路】模拟，注意分类讨论

【借鉴】除了模拟，其实可以从对角线的特征下手，毕竟同一对角线元素横纵坐标相加和相等，这个更加本质，代码会简洁不少。



**T509 斐波那契数**

模拟，当然了本题最快的方法是打表。



**T542 01矩阵 //python3**

【思路】我的思路应该来自dijkstra，本质上也是一种贪心，即：每次每个点“检查”自己周围四个点的值有没有变动，如果有的话就更新自己的状态。直到有一轮，所有的点都没有更新自己的状态，那么结束。

【思考】其实想想看这样的算法效率确实算不得高，虽然内存完爆所有提交的代码。除非牺牲内存，另外开一片空间记录上一次所有变动的点的坐标，然后下次直接变动其四周所有点，这样可以节省不少时间。

【借鉴】广搜当然可以啦，弄一个超级源点出来，广搜一开始入队全部的零点。动规也是可以的！因为广搜会重复搜，其实只需要考虑向右+向下和向左+向上即可，因为最短城际距离必然有两条（如果是直线，看做两条重合的），这个好理解。



**T543 二叉树的直径 //python3**

【思路】等于左子树高度和右子树高度之和+2，我是回溯实现的，节省了不少时间（代价是内存仅仅超过了百分之10，多用了3Mb吧，以前很少出现这种情况，毕竟C出身写过板子的应该在用内存上都非常扣）。当然本题可以直接对每个节点都去计算左子树和右子树的高度之和，但感觉这样做的话意义不大。



**T561 数组拆分一 //python3**

【思路】贪心



### T600~1000

**T657** **机器人能否回到原点** **//python3**

没啥好说的，s.count(<char>)是真的好用。



**T695 岛屿的最大面积 //python3**

英语翻译题。我做这种题的话，一般都是广度优先搜索，直接拓展开来求最大连通块。这倒是让我想到了写扫雷的逻辑的时候做的事情。



**T718 最长重复子数组//python3**

【思路】这题还是蛮简单的，思路上是简单动规。

【借鉴】这题用滑动窗口也是可以的，同样可以优化到O(N^2)



**T724 寻找数组的中心索引 //python3**

【思路】直接找就完事了。

【注意】优化有风险，优化须谨慎。已经吃过不止一次这个亏了，，，不要随便用大于二分之一求和来判断不存在，因为有可能是负数啊。



**T747 至少是其他数字两倍的最大数 //python3**

【思路】如何扫描一遍找到第一大和第二大的数？



**T771珠宝和石头(Jewels and Stones) //C++**

这题没什么好说的，有点浪费时间。不需要Hash，直接索引就行了。4ms过了，看别人的代码有0ms过的，快在他用了STL里面的vector，不知道空间会不会省，但时间足够快。

 

**T832** **翻转图像** **//python3**

Python自带list里面就有reverse函数，可以逆序。这道题有个有意思的地方在于Python的机制，如果是C++，一个二重循环必然可以解决；但是Python似乎必须写两次循环。如果直接在对行枚举的循环里面执行取反操作会报错，我也不知道为什么。



**T836 矩阵重叠 //python3**

反向判断，判断怎么样是不重叠就好了。



**T876 链表的中间结点 //python3**

模拟，考查链表的基础操作



**T892 三维形体的表面积 //python3**

模拟，先算上下两面，再挨个统计四周，四周只用统计比周围立方体高出的部分就好，剩下的都是被挡住的。



**T914 卡牌分组 //python3**

【思路】本题并不难想到要统计每种卡牌的数量然后计算最大公约数。

【借鉴】但是官方提供的代码就很优秀（略作改动，gcd这种还是可以自己写的），本题主要学习reduce()函数的用法，另外collection的这个Counter也很好用，真香啊：

```python
class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        def gcd(a:int, b:int)->int:
            return a if b==0 else gcd(b,a%b)
        vals = collections.Counter(deck).values()
        return reduce(gcd, vals) >= 2        
```



**T945 使数组唯一的最小增量 //python3**

【思路1】排序，可以用快排，但是我觉得符合题目本意的应该是计数排序。这本质上是一种贪心的思路，因为数组如何元素各不相同，“熵“最低的情况应该是按原来的顺序排成一个序列（序列中元素各不相同），所以无论是计数排序还是快排都是一样的想法，不过题目既给了元素大小又给了个数，明显更想让做题人用计数排序。

【思路2】哈希，本质上是一种线性的地址映射，额外开一片空间来保存当前的映射情况，比如“1”的位置已经被占了，要向后挪动，开一个数组记录当前挪动到了哪里，这样之后就不用重复搬移。理论上来说这样应该是最快的。



**T999 车的可用捕获量（可以一步捕获的棋子数） //python3**

【思路】这种题主要是要读清楚题目，注意是一次的捕获量，所以车只能跑一次。另外注意，python的for循环变量不会停在break的位置，而是停在循环末端的位置。



### T1000~

**T1013 将数组分为和相等的三部分 //python3**

【思路】首先求和，然后判断能否被3整除，不能的话直接返回False。然后我就开始了我天秀的想当然操作。其实只要将和分成三份，在累积求和的过程中发现第一份出现，在那之后发现第二份出现（并且不是在末尾出现，防止0,0），就可以了。但是我给它加了个提前判断返回（没有考虑负数），结果这题交了7遍，，，



**T1071 字符串的最大公因子 //python3**

【思路】这题要是按我的想法，从首位开始判断是否相等，一直相等的话分别判周期性，这样就非常麻烦了

【借鉴】如果s1+s2!=s2+s1，直接返回空，如果满足，求最大公约数，返回长度为最大公约数的子串即可。



**T1108 IP地址无效化 //python3**

首先学到的是python类中函数的定义，self是一个类似于C++中类指针this的东西，它的函数返回值的定义是在冒号前完成的，用-><类型>:来表示。

Python的字符串操作和MATLAB非常类似，len()可以直接得到字符串的长度，’+’可以连接两个字符串，可以直接用for i in range(len(s))来遍历字符串位数。



**T1160 拼写单词 //python3**

【思路】计数，储存，类似于Hash的思路

【注意】特别在python这类自由度极高的高级语言中，很容易忽视一些底层的问题。比如这道题需要进行数组的拷贝，就会有深拷贝浅拷贝的问题。在C之类的语言中，在写a(list)=b(list)的时候会很明白地想到这是指针，实质上a和b共用一片内存（MATLAB中这样写是默认不公用内存的），但是python在这个问题上更像C，本题我调了几遍之后明白了python列表赋值的机理，也是很有收获的。所以拷贝过程理所当然地成了b=[a[i] for i in range(len(a))]



【注意】下面这道题没提交

**T1162 地图分析 //python3**

【注意】写这道题一开始我犯了个迷糊，把平方写成了N^2（MATLAB写法），其实应该是N**2。改过来之后顺手查了下，^表示按位异或。



**T1248 统计优美子数组**

【思路】拿笔画了一下来了思路，这个问题可以拆分成子问题（虽然不能叠加），不过有记忆化的东西在里面。我们只需要统计以每个元素结尾的优美子序列数目，然后相加就可以了。如何统计？记录每两个奇数之间的偶数，以当前元素结尾的优美子序列数目就是前k-1个奇数到前k个奇数之间的偶数个数。

【借鉴】官方题解是相乘的哈，因为连续偶数的解数目是一样的（其实就是把我的方法中相加变成相乘）。但是我认为相乘还要讨论边界条件，不划算的。反正是要判定奇数偶数，不如相加。



## Interview-Questions

### 剑指offer

**剑指03 数组中重复的数字**

【思路】模拟，集合的应用/collection的应用



**剑指04 二维数组中的查找**

【思路】二分查找。

【注意】写代码的时候注意力要集中，常见问题不要总是写错，比如讲数组的下标是否越界等等。



**剑指05 替换空格**

【思路】字符串操作

【注意】不要使用split()，多个空格只会识别一个（它只管分割，不会管有几个空格的）



**剑指09 用两个栈实现队列**

【思路】翻转两次，用两个栈，一个在入队时操作，入队的同时压栈。另一个在出队的时候操作，出队的同时把入队栈的东西弹栈（然后再压栈、弹栈），翻转两次就成了先进先出。



**剑指10-1 斐波那契数列**

【思路】通过本题我也有心对比一下直接求和与快速幂的效率区别，毕竟取模是一个挺麻烦的操作。结论是100以内这个数据量用快速幂反而慢出天际，，，

【备注】第70题、第530题和本题一样

```python
class Solution:
    def fib(self, n: int) -> int:
        def multi(x:List[List[int]], y:List[List[int]]) -> List[List[int]]:
            m = len(x)
            n = len(x[0])
            s = len(y[0])
            tmp = [[0 for i in range(s)]for j in range(m)]
            for i in range(m):
                for j in range(n):
                    for k in range(s):
                        tmp[i][k] += x[i][j]*y[j][k] % 1000000007
            return tmp
        fib = [[0,1],[1,1]]
        a = [[0],[1]]
        while n>0:
            if n & 1 == 1:
                a = multi(fib,a)
            n = n//2
            fib = multi(fib,fib)
        return a[0][0] % 1000000007
```



**剑指10-2 青蛙跳台阶问题**

所以这题我就打表了，在类里面直接生成数组，返回self.a[n]即可，95%/100%，这样都没有超过百分之百，前面那百分之五是什么神仙？？？



**剑指11 旋转数组的最小数字**

【借鉴】二分法，将mid与r比较，如果大，在右边；如果小，在左边。优化方法是长度小于10的时候直接暴搜，不过本题数据量太小体现不出来二分法的优越性。



**剑指13 机器人的运动范围**

【注意】本题是一个行走+限制范围的经典模型，问题在于，它要满足两个条件：一是满足限制，二是周围有满足限制的点（可达）

【思路】广度优先搜索，一边广搜一边判断，凡是到达过的点（不管满不满足条件），都标记为到过，不再入队。

【借鉴】虽然这题的数据范围像极了直接暴搜的样子，但是它真的可以递推啊，，，因为只能向右和向下，所以二维递推就好了啊，我怎么忘了这个，看着自己长长的广搜留下了眼泪。



**剑指40 最小的k个数**

【思路1】排序，然后输出，复杂度O(nlogn)，由于样例的特殊性（或者是python自带的sort过于优秀），这个居然会很快？68%/100%

【思路2】优先队列，维护一个包含k个数的优先队列，复杂度O(nlogk)。注意python自带的优先队列只能比更大的，所以输入的时候可以取一个相反数，这样就能得到更小的了。5%/100%，可能我用优先队列用的比较笨，这个反而比思路1来得慢？？？

【思路3】注意到题给描述中有数值范围，很容易想到计数排序的思路，构建一个10001长度的列表，用计数排序的方法统计前k个数，理论复杂度O(n)，空间复杂度O(max(arr))，测试结果52%/100%，这个时间？？这个空间？？这题的测试样例？？

【思路4】快速选择算法（emmmm我懒，暂时没有写这个代码）

【思路5】BFPRT算法，至于为什么叫BFPRT算法，大概（一定）是因为它是由Blum、Floyd、Pratt、Rivest、Tarjan提出的吧。它只能躺在我的收藏夹吃灰了，看了一眼思路，我是不会写的。



**剑指51 数组中的逆序对**

【借鉴】经典算法，用归并排序求解逆序对问题，O(N^2)优化到O(NlogN)



**剑指56-1 数组中数字出现的次数**

【借鉴】经典位运算，首先，如果要找出双元素数组中唯一落单的那个，可以直接异或。如果有两个落单的，可以异或得到两个数的异或值，然后找到出现不同的位置，用与运算将原数组分为两类，一类中包含一个落单的，并且相同的数字一定在同一类中。对两类分别累计异或即可得到想要的两个值。



### 面试题

**面试题01.01 判定字符是否唯一**

【思路】翻译



**面试题 01.06 字符串压缩**

【思路】英语翻译

【注意】仔细读题，考虑”大于“还是”大于等于”



**面试题08.11 硬币**

【借鉴】完全背包

【注意】这题主要的坑点在于它是一个组合问题，其实按照上台阶的思路去做是没问题的，但是上台阶是一个排列问题（先1后2和先2后1是两种方案）。



**面16.03 交点**

【思路】几何题，近年来各种算法题都被各大网站透底透得差不多了，反而是几何题可能直接反映真实修养了。本题我一开始会想到用叉乘判断平行，相交自然是最容易的情况，平行之后判断是否共线，如果不共线返回空，共线需要讨论是否有交点，然后返回重合点中较小的坐标值。

【借鉴】代码比较麻烦，我偷懒没有自己写



**面试题17.16 按摩师**

这是每日一题打卡的时候出现的题目，个人感觉每日一题打卡活动推的题目都是很经典的，像这道题，虽然难度上确实是简单，但是确确实实要懂一些小技巧。

【思路】设定一个数组，记录到当前客户（必须包含当前客户）为止，所能收获的最大总预约时长。由于必须包含该客户，所以一定不能包含上一个客户。故而time[i] = max(time[0:i-2])，顺着递推，在递推的过程中，可以顺便把MAX的计算也做了，所以转移方程为：time[i] = max(MAX,time[i-2])+input[i]，时间复杂度O(n)，递推完成之后顺着扫描一遍找出time数组中最大的那个数就行了。空间复杂度O(n)，果然如我所想，82%/100%，很快。

```python
class Solution:
    def massage(self, nums: List[int]) -> int:
        ans = nums
        MAX = -2147483647
        for i in range(2,len(nums)):
            if ans[i-2]>MAX:
                MAX = ans[i-2]
            ans[i] += MAX
        MAX = 0
        for i in range(len(nums)):
            if ans[i]>MAX:
                MAX = ans[i]
        return MAX
```

【补充】写完思路之后我突然意识到（太蠢了），只需要记录三个数就行了，这题空间复杂度可以到O(1)的。改进的写法更新在T198打家劫舍里了，这两题一模一样。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if nums == []:
            return 0
        if len(nums) == 1:
            return nums[0]
        MAX = max(nums[0], nums[1])
        first, second = nums[0], MAX
        for i in range(2,len(nums)):
            if first + nums[i] > MAX:
                MAX = first + nums[i]
            first = second
            second = MAX
        return MAX
```

【借鉴】整个写完之后我看了下别人的想法，发现确实没有必要设置“一定包含”，这样的话dp[i]=max(dp[i-2]+nums[i],dp[i-1])就完事了。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if nums == []:
            return 0
        if len(nums) == 1:
            return nums[0]
        MAX = max(nums[0], nums[1])
        first, second = nums[0], MAX
        for i in range(2,len(nums)):
            MAX = max(first+nums[i], second)
            first = second
            second = MAX
        return MAX
```





## Weekly-Contest

### 179  2020/3/8

本周的比赛是在美服参加的，对应国服T5353和T5354（后来发现国服更新的慢，确实是美服的题号）

score: 7, time: 59:33, rank: 3051 / 6242

**T1374. Generate a String With Characters That Have Odd Counts //python3**

生成一个字符串，模拟题

**T1375. Bulb Switcher III //python3**

简单模拟，这题我用set()去判断的，做了一点优化，没有超时也是很神奇

后来看别人的代码，直接判断第i次的时候最大值是不是i就行了，多简单

**回顾**

本次周赛题并不困难，第三题就是广度优先遍历一下树就可以了。但是我11点多才开始做这个比赛，又蠢到把BFS写错了= =。



### 180  2020/3/15

本周比赛回到国服进行，预计之后应该都会在国服参赛了

score: 11, time: 58:15+5min=1:03:15, rank: 747 / 3714 || 2930 / 10047

**T1380 矩阵中的幸运数 //python3**

其实我感觉类似这种题，不用过多地去想如何优化，直接翻译就好了，一般不会超时

**T1381 设计一个支持增量操作的栈 //python3**

本题需要熟悉类和对象的基本操作，另外用数组实现一下基本数据类型：栈。感觉这题还挺有意思。

【注意】类的构造函数，每次提交需要注意刷新相关变量。已经不止一次因为这个丢分了，它的测试运行是会保留上一个输入数据的类中变量的。

```python
class CustomStack:
    stack = []
    MAX = 0
    
    def __init__(self, maxSize: int):
        self.MAX = maxSize
        self.stack = []

    def push(self, x: int) -> None:
        if len(self.stack)<self.MAX:
            self.stack.append(x)

    def pop(self) -> int:
        if self.stack == []:
            return -1
        else:
            ans = self.stack[len(self.stack)-1]
            del self.stack[len(self.stack)-1]
            return ans

    def increment(self, k: int, val: int) -> None:
        if len(self.stack)<k:
            for i in range(len(self.stack)):
                self.stack[i] += val
        else:
            for i in range(k):
                self.stack[i]+=val


# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
```

**T1382 将二叉搜索树变平衡 //python3**

【思路】一开始看到这道题我是很慌的，因为AVL树的那些操作我基本都忘光了。但是静下来思考，发现并不需要复杂的数据结构知识。因为题目给的就已经是二叉搜索树了，所以中序遍历即可得到一个包含树上所有元素的有序数组。然后把这个有序数组递归生成平衡树即可。

【补充】在具体实现的时候，参考数据范围，我没有做中序遍历（图省事儿），直接把所有元素放出来做了一遍排序，这样时间效率肯定大打折扣，但是不会超时。

**T1383 最大的团队表现值 //python3**

【思路】拿到这道题我想了很多，最先排除的是贪心（，，，），想了很长时间的动态规划，但是发现本题似乎并不具备最优子结构。最终想到，如果枚举最小的效率，然后只需要从效率更高的人中找k-1（如果不足k-1个，有多少来多少）个速度最快的就行了。所以建立一个包含index、速度和效率的列表，以速度为关键字排序，再以效率为关键字排序（sort默认的是，放在首位的是排序主关键字）。但是这样会存在很大的问题：为了保证当前枚举的人是计算中效率最低的（必须包括且必须是效率最低），需要依次删除枚举的人，并对剩下的人进行重新排序。这个就非常麻烦了，时间效率直指N^2，结果可想而知，超时（不过过了51个点，最后两个点超时）

```python
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        Mod = 10**9+7
        sl, el = [], []
        for i in range(n):
            el.append([efficiency[i],speed[i],i])
            sl.append([speed[i],efficiency[i],i])
        el.sort()
        sl.sort()
        MAX = 0
        for i in range(n):
            n = len(sl)
            ee, ss, ii = el[i][0], el[i][1], el[i][2]
            if n>k:
                sss = sl[n-k:n]
            else:
                sss = sl
            summ = 0
            if [ss,ee,ii] in sss:
                for j in range(len(sss)):
                    summ+=sss[j][0]
            else:
                sss = sss[1:len(sss)]
                summ += ss
                for j in range(len(sss)):
                    summ += sss[j][0]
            if summ*ee>MAX:
                MAX = summ*ee
            sl.remove([ss,ee,ii])
        return MAX% Mod
```

【借鉴】可以维护一个优先队列，来取出前k个。注意，我借鉴的思路是倒着推的，为什么倒着推？因为，按照我的思路，最小的效率必须被包含（正着推的话）。但是如何倒着推，最小的效率不需要一定包含：因为只有在最小效率的speed大到前k位的时候它才被包含，如果没有大到前k位，之前肯定计算出过更大的结果。下面把别人的代码贴上，写得非常漂亮。

```python
from queue import PriorityQueue
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        items = [(speed[i], efficiency[i]) for i in range(n)]
        items.sort(key=lambda item:item[1], reverse=True)
        add_sum = 0
        pq = PriorityQueue()
        res = 0
        for i in range(n):
            pq.put(items[i][0])
            add_sum += items[i][0]
            if pq.qsize() > k:
                add_sum -= pq.get()
            val = add_sum * items[i][1]
            if val > res:
                res = val
        return res % (10 ** 9 + 7)
```



### 181  2020/3/22

本周比赛在国服进行，艰难AK

score: 18, time: 1:08:23+5min=1:13:23, rank: 128 / 4148 || 495 / 10930

**T1389 按既定顺序创建目标数组**

本题考查对各语言标准库函数的应用，python3的话直接array.insert(index,num)即可。

**T1390 四因数**

本题是数学题，考查埃拉托斯特尼筛法的变形。如果一个数n要有正好四个因数，那么它首先不能是完全平方数；其次是在2~sqrt(n)之间只能有一个数可以被其整除。对本题而言，使用筛法检测的时间复杂度为O(nsqrt(max(num)))，对照数据范围可知筛法完全可以轻松应对。

**T1391 检测网络中是否存在有效路径**

本题的灵感可能来自于《太阁立志传5》的灌溉训练。

【思路】BFS，由于每个“块”只有两个方向通向下一个块，所以这是一棵二叉树，宽度优先遍历它即可很快得到其是否存在路径。我的思路是建立一个邻接矩阵来判定类型为index1和index2的两块是否可以连通，剩下的思路就如何走迷宫。

**T1392 最长快乐前缀**

【借鉴】

本题不是我自己做出来的。拿到这道题我首先想到了KMP算法，本身KMP算法简化一下就是前后缀匹配，而正好网上有KMP算法的代码，我把C++改成了python再小做修改就过了（据说python暴力也能过？）。

```python
class Solution:
    def longestPrefix(self, s: str) -> str:
        next = [0 for i in range(len(s)+1)]
        def getnext(s:str) ->None:
            n = len(s)
            next[0] = 0
            i = 0
            for j in range(1,len(s)):
                while(s[i]!=s[j] and i>0):
                    i = next[i-1]
                if (s[i]==s[j]):
                    i += 1
                    next[j] = i
                else:
                    next[j] = 0
        getnext(s)
        return s[0:next[len(s)-1]]
```



### 182  2020/3/29

本周比赛提前放弃了，最后一题想了半个小时，并没有思路。

score: 12, time:22:08, rank: 147 / 3910 || 667 / 11694

**T1394 找出数组中的幸运数**

【思路】统计频次，注意找不到的情况即可

**T1395 统计作战单位**

【思路】暴力枚举，O(N^3)，看数据范围是可以过的

**T1396 设计地铁系统**

【思路】纯模拟，记录对应ID的出入站时间地点，对应检索即可

**T1397 找到所有的好字符串**

【想法】个人感觉这肯定是个数学题，有组合数学的味道，字典序大于s2小于s1的字符串数量很容易统计，关键在于如何计算不包含evil字符串的数量？目前想法是反过来计算包含evil的数量，这样的话就要从失配位置开始，逐个统计后插，用容斥原理补上多去掉的数目，但是想想都很复杂啊，，，如果evil太长了，容斥原理公式会很麻烦。

【借鉴】

此处参考别人的代码：



### 184  2020/4/12

上周玩游戏去了没有参加，本周参赛主要是为了下周六的2020年力扣杯春季全国程序设计大赛做准备。

本周题目比较简单，虽然我上来第一题就罚了时，中途去了次WC，但还是一个小时AK了。

score: 19, time: 0:59:04+5min = 1:04:04, rank: 232 / 3846 || 1013 / 13661

**T1408 数组中的字符串匹配**

【思路】枚举

【注意】这题是有坑的！虽然题目中保证给出的字符串没有重复的，但是如果暴力枚举的时候不注意break，会导致结果中有重复项，比如{od,odd,oddd}，如果不发现子串后立刻break，就会输出两边od！因为这个被罚时多亏啊。

**T1409 查询带键的排列**

【思路】模拟

【注意】如何将一个元素改变位置，其他元素位置相对不变？

**T1410 HTML实体解析器**

【思路】字符串操作

【注意】打表需谨慎，一定要好好检查表打得对不对

**T1411 给N乘3的网格图涂色的方案数**

【思路】递推

【解析】本题把n=1的12种状态给出来了，这无疑直接提供了思路，使得题目难度大大降低。不然说实话这题还挺麻烦的，要自己去分析状态的转移。

【借鉴】个人感觉，如果没有做过类似的题目，上面这种思路是最容易想到的，就是直接分析状态转移然后递推。本题借鉴大佬的思路，可以分为abc和aba两种情况，每种的初始状态都是6种，然后abc可以衍生bca、cab两种和bab、bcb两种，aba可以衍生bac、cab两种和bab、bcb、cac三种，然后两项递推求和即可，时间复杂度会低不少。



### 185  2020/4/19

本周是周赛+字节跳动春招，相对来讲参赛人员感觉都认真了很多。在大家普遍认真对待的情况下就把目前我的真实水平反映出来了。主要问题有以下几点：

1. 心态不稳，慌得一批。习惯了前两题不费劲秒杀，出了问题或者WA就开始手足无措。远远做不到“握剑而起，心必如常”。
2. 思路不清晰，基本靠直觉，没有清晰的解题套路和想法，不会归类
3. 部分专题掌握得太差，各种动规还有特别是哈希map基本是空白，有畏惧感
4. 代码能力不够，python的很多基本用法没掌握，写起来跟C一样还没有C严谨
5. 即使有思路，码的过程中也做不到按思路来，码了二十行就忘了自己要干嘛
6. 细节把握不够，慌，认为周赛就不需要把握细节（这次把大小写弄错那个WA就很要命，辛亏题目还给出了错误细节，不然可能很难找到），分析复杂度也不到位。

score: 12, time: 0:51:04+2*5min = 1:01:04, rank: 436 / 5002 || 1795 / 14208

**T1416 重新格式化字符串**

【思路】强调明确、简洁的思路

怎么样算明确简洁？

分开统计数字和字母，如果数量差别绝对值大于1返回-1

如果数字和字母一样多，for长度，插数字插字母

如果数字比字母长一个，插数字，for字母长度，插字母插数字（+1）

如果字母比数字长一个，插字母，for数字长度，插数字插字母（+1）

其实非常简单，按这个思路写不可能写10分钟的。

**T1417 点菜展示表**

【思路】这题确实恶心人，恶心人的点在于刷力扣时间长了之后，控制输入输出格式的水平确实有所下降

【注意】细节，大小写

**T1418 数青蛙**

【思路】俄罗斯方块，这其实就是个模拟

【注意】还是注意思路的清晰，怎么样叫稳呢，思路清晰，比赛的时候加满一次croak我忘了减掉。



最后一题是三维动规。唉。



### 186  2020/4/26【T239待补】

score: 18, time: 0:57:51+3*5min = 1:12:51, rank: 107 / 3107 || 488 / 11684

**T1422 分割字符串的最大得分**

【思路】比赛的时候是N^2枚举的，现在想想可以前缀和优化到N的

**T1423 可获得的最大点数**

【思路】这次的出题人特别喜欢前缀和啊，这题又是前缀和，O(n+k)

**T1424 对角线遍历二**

【思路】一开始我是想着模拟来着，不过这题吧，它都是左下到右上的，那简单了，i+j为主关键字，j为次关键字，排序就好了。

**T1425 带限制的子序列和**

【思路】经典DP最大连续子序列和的改动版本

【借鉴】子问题就是如何求滑动串口最大值，也就是【LeetCodeT239】，单调队列法。







## LPC

### 2020-spring-solo

score: 20/30, time: 1:24:34+5*5min = 1:49:34, rank: 238/4093(9293)

**LCP 06 拿硬币**

【思路】模拟

**LCP 07  传递信息**

【思路】模拟，图的连通性问题

【借鉴】看到一个有趣的思路是求可达矩阵，01邻接矩阵的N次幂表示可达路径条数，挺有意思的，可以用快速幂优化，如果k很大用这个确实非常赞

**LCP 08 剧情触发时间**

【思路】我的思路是模拟，累加时间，然后累加资源，搜索事件，触发事件。然后超时了，做了一下优化，改成将事件按文明等级排序，从上次失配位置-k开始找下一次事件。

【借鉴】这题充分证明了我基础不扎实，陷入了模拟的深坑无法自拔。既然按时间累加的资源的是一个有序数列，为什么不能反过来在这个时间序列中查找事件呢？

要知道，这不是真的让你玩游戏，是事后分析事件，不需要实时播报。

**LCP 09 最小跳跃次数**

【思路】广搜+剪枝。显然广搜会超时

1. 剪枝思路一：枚举到过的点，到过的点不再入队。因为这会形成环路，必然使得最终的步数增大，是无意义解。超时
2. 剪枝思路二：对到过的点进行Hash，将查询是否到过降到O(1)，依然超时
3. 剪枝思路三：既然每次到一个点，下次就要到左边所有点，那直接记录这个点为当前到过最大值就好，小于这个最大值的点都不要再进了。通过

【借鉴】本题有动规思路

**最后一题是树状动规**  不会，难受



### 2020-spring-team

score: 16/42, time: 2:03:04, rank: 77/1066(2702)

**LCP 11 期望个数统计**

【思路】概率论问题，全排列后重叠的期望为1，所以是求不重复元素个数，对python来讲就是转换为set求容量

**LCP 15 游乐园的迷宫**

【借鉴】贪心，可以从凸包上的一个点出发，如果下一步是L，就让所有的点都在当前连线的左边（排序即可，这里是角排序）；如果下一步是R，就让所有点都在当前连线的右边。这样每一次的选择容量都是最大的。

【思路】比赛的时候我自己写的是回溯，暴搜也能通过这道题的数据。



## Postscript

 LeetCode可能确实是网络上最简单的成年人oj，难度确实和ICPC什么的没法比，但是我始终觉得：把简单的东西做好就是不简单。在实际工作当中，可能连LeetCode-hard级别的问题也是很少遇到的，因而从功利的角度来说，LeetCode也许是工科狗的最好选择——毕竟大部分人这辈子都用不到AC自动机或者树状DP，甚至连FFT也不可能自己动手写一遍。

不管怎么说，闲暇时光写一写，总比开把游戏来得实惠些。